'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _class, _temp;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _miniStore = require('mini-store');

var _merge = require('lodash/merge');

var _merge2 = _interopRequireDefault(_merge);

var _componentClasses = require('component-classes');

var _componentClasses2 = _interopRequireDefault(_componentClasses);

var _reactLifecyclesCompat = require('react-lifecycles-compat');

var _utils = require('./utils');

var _ColumnManager = require('./ColumnManager');

var _ColumnManager2 = _interopRequireDefault(_ColumnManager);

var _HeadTable = require('./HeadTable');

var _HeadTable2 = _interopRequireDefault(_HeadTable);

var _BodyTable = require('./BodyTable');

var _BodyTable2 = _interopRequireDefault(_BodyTable);

var _ExpandableTable = require('./ExpandableTable');

var _ExpandableTable2 = _interopRequireDefault(_ExpandableTable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Table = (_temp = _class = function (_React$Component) {
    _inherits(Table, _React$Component);

    function Table(props) {
        _classCallCheck(this, Table);

        var _this = _possibleConstructorReturn(this, (Table.__proto__ || Object.getPrototypeOf(Table)).call(this, props));

        _this.state = {};

        _this.getRowKey = function (record, index) {
            var rowKey = _this.props.rowKey;
            var key = typeof rowKey === 'function' ? rowKey(record, index) : record[rowKey];
            (0, _utils.warningOnce)(key !== undefined, 'Each record in table should have a unique `key` prop,' + 'or set `rowKey` to an unique primary key.');
            return key === undefined ? index : key;
        };

        _this.handleWindowResize = function () {
            _this.setScrollPositionClassName();
        };

        _this.handleBodyScrollLeft = function (e) {
            // Fix https://github.com/ant-design/ant-design/issues/7635
            if (e.currentTarget !== e.target) {
                return;
            }
            var target = e.target;
            var headTable = _this.headTable,
                bodyTable = _this.bodyTable;

            if (target.scrollLeft !== _this.lastScrollLeft) {
                _this.setScrollPositionClassName();
                if (_this.useFixedHeader()) {
                    if (target === bodyTable && headTable) {
                        headTable.scrollLeft = target.scrollLeft;
                    } else if (target === headTable && bodyTable) {
                        bodyTable.scrollLeft = target.scrollLeft;
                    }
                }
            }
            // Remember last scrollLeft for scroll direction detecting.
            _this.lastScrollLeft = target.scrollLeft;
        };

        _this.handleBodyScroll = function (e) {
            _this.handleBodyScrollLeft(e);
        };

        _this.saveRef = function (name) {
            return function (node) {
                _this[name] = node;
            };
        };

        _this.useFixedHeader = function () {
            var _this$props = _this.props,
                useFixedHeader = _this$props.useFixedHeader,
                scroll = _this$props.scroll;

            return useFixedHeader || scroll && scroll.y;
        };

        _this.columnManager = new _ColumnManager2.default(props.columns);

        _this.store = (0, _miniStore.create)({
            fixedColumnsHeadRowsHeight: [],
            fixedColumnsBodyRowsHeight: {}
        });

        _this.debouncedWindowResize = (0, _utils.debounce)(_this.handleWindowResize, 150);
        return _this;
    }

    _createClass(Table, [{
        key: 'getChildContext',
        value: function getChildContext() {
            return {
                table: {
                    props: this.props,
                    columnManager: this.columnManager,
                    saveRef: this.saveRef,
                    components: (0, _merge2.default)({
                        table: 'table',
                        header: {
                            wrapper: 'thead',
                            row: 'tr',
                            cell: 'th'
                        },
                        body: {
                            wrapper: 'tbody',
                            row: 'tr',
                            cell: 'td'
                        }
                    }, this.props.components)
                }
            };
        }
    }, {
        key: 'componentDidUpdate',
        value: function componentDidUpdate(prevProps) {
            // when table changes to empty, reset scrollLeft
            if (prevProps.data.length > 0 && this.props.data.length === 0 && this.hasScrollX()) {
                this.resetScrollX();
            }
        }
    }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
            if (this.resizeEvent) {
                this.resizeEvent.remove();
            }
            if (this.debouncedWindowResize) {
                this.debouncedWindowResize.cancel();
            }
        }
    }, {
        key: 'componentDidMount',
        value: function componentDidMount() {
            this.setScrollPositionClassName();
        }
    }, {
        key: 'setScrollPosition',
        value: function setScrollPosition(position) {
            this.scrollPosition = position;
            if (this.tableNode) {
                var prefixCls = this.props.prefixCls;

                (0, _componentClasses2.default)(this.tableNode).remove(new RegExp('^' + prefixCls + '-scroll-position-.+$')).add(prefixCls + '-scroll-position-' + position);
            }
        }
    }, {
        key: 'setScrollPositionClassName',
        value: function setScrollPositionClassName() {
            var node = this.bodyTable;
            var scrollToLeft = node.scrollLeft === 0;
            var scrollToRight = node.scrollLeft + 1 >= node.children[0].getBoundingClientRect().width - node.getBoundingClientRect().width;
            if (scrollToLeft && scrollToRight) {
                this.setScrollPosition('both');
            } else if (scrollToLeft) {
                this.setScrollPosition('left');
            } else if (scrollToRight) {
                this.setScrollPosition('right');
            } else if (this.scrollPosition !== 'middle') {
                this.setScrollPosition('middle');
            }
        }
    }, {
        key: 'resetScrollX',
        value: function resetScrollX() {
            if (this.headTable) {
                this.headTable.scrollLeft = 0;
            }
            if (this.bodyTable) {
                this.bodyTable.scrollLeft = 0;
            }
        }
    }, {
        key: 'hasScrollX',
        value: function hasScrollX() {
            var _props$scroll = this.props.scroll,
                scroll = _props$scroll === undefined ? {} : _props$scroll;

            return 'x' in scroll;
        }
    }, {
        key: 'renderMainTable',
        value: function renderMainTable() {
            var _props = this.props,
                scroll = _props.scroll,
                tableLayout = _props.tableLayout;


            var table = [this.renderTable({
                columns: this.columnManager.groupedColumns(),
                onScroll: scroll.onScroll,
                tableLayout: tableLayout
            }), this.renderEmptyText(), this.renderFooter()];

            return table;
        }
    }, {
        key: 'renderTable',
        value: function renderTable(options) {
            var _this2 = this;

            var columns = options.columns,
                onScroll = options.onScroll,
                tableLayout = options.tableLayout;


            var headTable = _react2.default.createElement(_HeadTable2.default, {
                key: 'head',
                columns: columns,
                tableClassName: '',
                handleBodyScrollLeft: this.handleBodyScrollLeft,
                expander: this.expander,
                tableLayout: tableLayout
            });

            var bodyTable = _react2.default.createElement(_BodyTable2.default, {
                key: 'body',
                columns: columns,
                tableClassName: '',
                getRowKey: this.getRowKey,
                handleBodyScroll: function handleBodyScroll(e) {
                    _this2.handleBodyScroll(e);
                    onScroll && onScroll(e);
                },
                expander: this.expander,
                tableLayout: tableLayout
            });

            return [headTable, bodyTable];
        }
    }, {
        key: 'renderTitle',
        value: function renderTitle() {
            var _props2 = this.props,
                title = _props2.title,
                prefixCls = _props2.prefixCls;

            return title ? _react2.default.createElement(
                'div',
                { className: prefixCls + '-title', key: 'title' },
                title(this.props.data)
            ) : null;
        }
    }, {
        key: 'renderFooter',
        value: function renderFooter() {
            var _props3 = this.props,
                footer = _props3.footer,
                prefixCls = _props3.prefixCls;

            return footer ? _react2.default.createElement(
                'div',
                { className: prefixCls + '-footer', key: 'footer' },
                footer(this.props.data)
            ) : null;
        }
    }, {
        key: 'renderEmptyText',
        value: function renderEmptyText() {
            var _props4 = this.props,
                emptyText = _props4.emptyText,
                prefixCls = _props4.prefixCls,
                data = _props4.data;

            if (data.length) {
                return null;
            }
            var emptyClassName = prefixCls + '-placeholder';
            return _react2.default.createElement(
                'div',
                { className: emptyClassName, key: 'emptyText' },
                typeof emptyText === 'function' ? emptyText() : emptyText
            );
        }
    }, {
        key: 'render',
        value: function render() {
            var _this3 = this;

            var props = this.props;
            var prefixCls = props.prefixCls;

            if (this.state.columns) {
                this.columnManager.reset(props.columns);
            }

            var className = props.prefixCls;
            if (props.className) {
                className += ' ' + props.className;
            }
            if (this.useFixedHeader()) {
                className += ' ' + prefixCls + '-fixed-header';
            }

            return _react2.default.createElement(
                _miniStore.Provider,
                { store: this.store },
                _react2.default.createElement(
                    _ExpandableTable2.default,
                    _extends({}, props, { columnManager: this.columnManager, getRowKey: this.getRowKey }),
                    function (expander) {
                        _this3.expander = expander;
                        return _react2.default.createElement(
                            'div',
                            { ref: _this3.saveRef('tableNode'), className: className, style: props.style },
                            _this3.renderTitle(),
                            _react2.default.createElement(
                                'div',
                                { className: prefixCls + '-content' },
                                _this3.renderMainTable()
                            )
                        );
                    }
                )
            );
        }
    }], [{
        key: 'getDerivedStateFromProps',
        value: function getDerivedStateFromProps(nextProps, prevState) {
            if (nextProps.columns && nextProps.columns !== prevState.columns) {
                return {
                    columns: nextProps.columns
                };
            }
            return null;
        }
    }]);

    return Table;
}(_react2.default.Component), _class.propTypes = Object.assign({
    data: _propTypes2.default.array,
    useFixedHeader: _propTypes2.default.bool,
    columns: _propTypes2.default.array,
    prefixCls: _propTypes2.default.string,
    bodyStyle: _propTypes2.default.object,
    style: _propTypes2.default.object,
    rowKey: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func]),
    rowClassName: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func]),
    onRow: _propTypes2.default.func,
    onHeaderRow: _propTypes2.default.func,
    showHeader: _propTypes2.default.bool,
    title: _propTypes2.default.func,
    footer: _propTypes2.default.func,
    emptyText: _propTypes2.default.oneOfType([_propTypes2.default.node, _propTypes2.default.func]),
    scroll: _propTypes2.default.object,
    rowRef: _propTypes2.default.func,
    tableLayout: _propTypes2.default.oneOf(['fixed', 'auto']),
    components: _propTypes2.default.shape({
        table: _propTypes2.default.any,
        header: _propTypes2.default.shape({
            wrapper: _propTypes2.default.any,
            row: _propTypes2.default.any,
            cell: _propTypes2.default.any
        }),
        body: _propTypes2.default.shape({
            wrapper: _propTypes2.default.any,
            row: _propTypes2.default.any,
            cell: _propTypes2.default.any
        })
    })
}, _ExpandableTable2.default.propTypes), _class.childContextTypes = {
    table: _propTypes2.default.any,
    components: _propTypes2.default.any
}, _class.defaultProps = {
    data: [],
    useFixedHeader: false,
    rowKey: 'key',
    rowClassName: function rowClassName() {
        return '';
    },
    onRow: function onRow() {},
    onHeaderRow: function onHeaderRow() {},

    prefixCls: 'rc-table',
    bodyStyle: {},
    style: {},
    showHeader: true,
    scroll: {},
    rowRef: function rowRef() {
        return null;
    },
    emptyText: function emptyText() {
        return 'No Data';
    }
}, _temp);


(0, _reactLifecyclesCompat.polyfill)(Table);

exports.default = Table;