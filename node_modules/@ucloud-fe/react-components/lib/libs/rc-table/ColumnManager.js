'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _checkStickySupport = require('../../utils/checkStickySupport');

var _checkStickySupport2 = _interopRequireDefault(_checkStickySupport);

var _warning = require('../../utils/warning');

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var supportSticky = (0, _checkStickySupport2.default)();

var ColumnManager = function () {
    function ColumnManager(columns) {
        _classCallCheck(this, ColumnManager);

        this._cached = {};

        this.reset(columns);
    }

    _createClass(ColumnManager, [{
        key: 'leafColumns',
        value: function leafColumns() {
            var _this = this;

            return this._cache('leafColumns', function () {
                return _this._leafColumns(_this.columns);
            });
        }

        // add appropriate rowspan and colspan to column

    }, {
        key: 'groupedColumns',
        value: function groupedColumns() {
            var _this2 = this;

            return this._cache('groupedColumns', function () {
                var _groupColumns = function _groupColumns(columns) {
                    var currentRow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                    var parentColumn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
                    var rows = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];

                    // track how many rows we got
                    rows[currentRow] = rows[currentRow] || [];
                    var grouped = [];
                    var setRowSpan = function setRowSpan(column) {
                        var rowSpan = rows.length - currentRow;
                        if (column && !column.children && // parent columns are supposed to be one row
                        rowSpan > 1 && (!column.rowSpan || column.rowSpan < rowSpan)) {
                            column.rowSpan = rowSpan;
                        }
                    };
                    columns.forEach(function (column, index) {
                        var newColumn = Object.assign({}, column);
                        rows[currentRow].push(newColumn);
                        parentColumn.colSpan = parentColumn.colSpan || 0;
                        if (newColumn.children && newColumn.children.length > 0) {
                            newColumn.children = _groupColumns(newColumn.children, currentRow + 1, newColumn, rows);
                            parentColumn.colSpan += newColumn.colSpan;
                        } else {
                            parentColumn.colSpan++;
                        }
                        // update rowspan to all same row columns
                        for (var i = 0; i < rows[currentRow].length - 1; ++i) {
                            setRowSpan(rows[currentRow][i]);
                        }
                        // last column, update rowspan immediately
                        if (index + 1 === columns.length) {
                            setRowSpan(newColumn);
                        }
                        grouped.push(newColumn);
                    });
                    return grouped;
                };
                return _groupColumns(_this2.columns);
            });
        }
    }, {
        key: 'reset',
        value: function reset(columns) {
            if (supportSticky) {
                columns = [].concat(_toConsumableArray(columns));
                var leftOffset = 0,
                    leftPos = 0;
                for (; leftPos < columns.length; leftPos++) {
                    var column = Object.assign({}, columns[leftPos]);
                    if (column.fixed === 'left' || column.fixed === true) {
                        if (leftOffset === false) {
                            (0, _warning2.default)('every left fixed columns before the latest should have a valid width');
                            break;
                        }
                        column.offset = leftOffset;
                        column.fixed = 'left';
                        if (column.width) {
                            leftOffset += column.width;
                        } else {
                            leftOffset = false;
                        }
                        columns[leftPos] = column;
                    } else {
                        break;
                    }
                }
                if (leftPos > 0) columns[leftPos - 1].latestLeftFixed = true;

                var rightOffset = 0,
                    rightPos = columns.length - 1;
                for (; rightPos > 0; rightPos--) {
                    var _column = Object.assign({}, columns[rightPos]);
                    if (_column.fixed === 'right' || _column.fixed === true) {
                        if (rightOffset === false) {
                            (0, _warning2.default)('every right fixed columns after the first should have a valid width');
                            break;
                        }
                        _column.offset = rightOffset;
                        _column.fixed = 'right';
                        if (_column.width) {
                            rightOffset += _column.width;
                        } else {
                            rightOffset = false;
                        }
                        columns[rightPos] = _column;
                    } else {
                        break;
                    }
                }
                if (rightPos < columns.length - 1) columns[rightPos + 1].firstRightFixed = true;
            }
            this.columns = columns;
            this._cached = {};
        }
    }, {
        key: '_cache',
        value: function _cache(name, fn) {
            if (name in this._cached) {
                return this._cached[name];
            }
            this._cached[name] = fn();
            return this._cached[name];
        }
    }, {
        key: '_leafColumns',
        value: function _leafColumns(columns) {
            var _this3 = this;

            var leafColumns = [];
            columns.forEach(function (column) {
                if (!column.children) {
                    leafColumns.push(column);
                } else {
                    leafColumns.push.apply(leafColumns, _toConsumableArray(_this3._leafColumns(column.children)));
                }
            });
            return leafColumns;
        }
    }]);

    return ColumnManager;
}();

exports.default = ColumnManager;