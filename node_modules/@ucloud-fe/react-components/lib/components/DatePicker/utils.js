'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isRangeDateValid = exports.getValidDate = exports.isRangeDateDisabled = exports.isDateDisabled = undefined;

var _each2 = require('lodash/each');

var _each3 = _interopRequireDefault(_each2);

var _isEmpty2 = require('lodash/isEmpty');

var _isEmpty3 = _interopRequireDefault(_isEmpty2);

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _moment = require('moment');

var _moment2 = _interopRequireDefault(_moment);

var _utils = require('../Calendar/utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 *
 * @param {moment{}} date 判断的时间
 * @param {moment{}} value 当前的时间
 * @param {object} rules 规则
 * @param {moment{}} start 当前开始时间
 * @param {moment{}} end 当前结束时间
 * @param {string} tag 标记
 */
var isRangeDateDisabled = function isRangeDateDisabled(date, value, rules, start, end, tag) {
    date = (0, _moment2.default)(date);
    value = (0, _moment2.default)(value);
    start = (0, _moment2.default)(start);
    end = (0, _moment2.default)(end);

    if (!rules) {
        return false;
    }
    var range = rules.range,
        _c = rules.custom,
        minRange = rules.minRange;


    var custom = function custom(date, value) {
        if (!(0, _isEmpty3.default)(range)) {
            if (tag === 'start') {
                if (minRange) {
                    if (date > (0, _moment2.default)(end).subtract(minRange)) {
                        return true;
                    }
                }
            } else if (tag === 'end') {
                if (minRange) {
                    if (date < (0, _moment2.default)(start).add(minRange)) {
                        return true;
                    }
                }
            }
        }
        if (_c) {
            return _c(date, value, start, end, tag);
        }
    };

    return (0, _utils.isDateDisabled)(date, value, {
        range: range,
        custom: custom
    });
};

var isRangeDateValid = function isRangeDateValid(start, end, rules, precision) {
    start = (0, _moment2.default)(start);
    end = (0, _moment2.default)(end);
    var precisionMap = {
        millisecond: 0,
        second: 1,
        minute: 2,
        hour: 3,
        date: 4,
        month: 5,
        year: 6
    };
    var resetValueMap = {
        millisecond: 0,
        second: 0,
        minute: 0,
        hour: 0,
        date: 1,
        month: 0
    };
    var resetMap = void 0;
    if (precision) {
        var precisionLevel = precisionMap[precision];
        resetMap = {};
        (0, _each3.default)(precisionMap, function (level, key) {
            if (level < precisionLevel) {
                resetMap[key] = resetValueMap[key];
            }
        });
        start.set(resetMap);
        end.set(resetMap);
    }
    var range = rules.range,
        maxRange = rules.maxRange,
        minRange = rules.minRange;


    if (start > end) {
        return 'startGreaterThanEnd';
    }
    if (range) {
        var _range = _slicedToArray(range, 2),
            s = _range[0],
            e = _range[1];

        s = (0, _moment2.default)(s);
        e = (0, _moment2.default)(e);
        if (resetMap) {
            s.set(resetMap);
            e.set(resetMap);
        }
        if (s != null && start < s) {
            return 'rangeError';
        }
        if (e != null && end > e) {
            return 'rangeError';
        }
    }
    if (maxRange && (0, _moment2.default)(start).add(maxRange) < end) {
        return 'maxRangeError';
    }
    if (minRange && (0, _moment2.default)(end).subtract(minRange) < start) {
        return 'minRangeError';
    }
    return true;
};

exports.isDateDisabled = _utils.isDateDisabled;
exports.isRangeDateDisabled = isRangeDateDisabled;
exports.getValidDate = _utils.getValidDate;
exports.isRangeDateValid = isRangeDateValid;