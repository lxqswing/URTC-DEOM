'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _isObject2 = require('lodash/isObject');

var _isObject3 = _interopRequireDefault(_isObject2);

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _class, _temp, _initialiseProps; /**
                                      * copy from rc-input-number
                                      */

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _Icon = require('../../components/Icon');

var _Icon2 = _interopRequireDefault(_Icon);

var _Tooltip = require('../../components/Tooltip');

var _Tooltip2 = _interopRequireDefault(_Tooltip);

var _KeyCode = require('../../interfaces/KeyCode');

var _KeyCode2 = _interopRequireDefault(_KeyCode);

var _style = require('./style');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function noop() {}

function defaultParser(input) {
    return input.replace(/[^\w.-]+/g, '');
}

var SPEED = 200;
var DELAY = 600;

var StyleType = ['default', 'split', 'pagination'];
var Size = ['sm', 'md', 'lg'];
/**
 * Max Safe Integer -- on IE this is not available, so manually set the number in that case.
 * The reason this is used, instead of Infinity is because numbers above the MSI are unstable
 */
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || Math.pow(2, 53) - 1;

var NumberInput = (_temp = _class = function (_Component) {
    _inherits(NumberInput, _Component);

    function NumberInput(props) {
        _classCallCheck(this, NumberInput);

        var _this = _possibleConstructorReturn(this, (NumberInput.__proto__ || Object.getPrototypeOf(NumberInput)).call(this, props));

        _initialiseProps.call(_this);

        var value = void 0;
        if ('value' in props) {
            value = props.value;
        } else {
            value = props.defaultValue;
        }
        value = _this.toNumber(value);

        _this.state = {
            inputValue: _this.toPrecisionAsStep(value),
            value: value,
            focused: props.autoFocus,
            tooltipVisible: false
        };
        return _this;
    }

    _createClass(NumberInput, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            this.componentDidUpdate();
        }
    }, {
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            if ('value' in nextProps) {
                var value = this.state.focused ? nextProps.value : this.getValidValue(nextProps.value, nextProps.min, nextProps.max);
                this.setState({
                    value: value,
                    inputValue: this.inputting ? value : this.toPrecisionAsStep(value)
                });
            }
        }
    }, {
        key: 'componentWillUpdate',
        value: function componentWillUpdate() {
            try {
                this.start = this.input.selectionStart;
                this.end = this.input.selectionEnd;
            } catch (e) {
                // Fix error in Chrome:
                // Failed to read the 'selectionStart' property from 'HTMLInputElement'
                // http://stackoverflow.com/q/21177489/3040605
            }
        }
    }, {
        key: 'componentDidUpdate',
        value: function componentDidUpdate() {
            // pressingUpOrDown is true means that someone just click up or down button
            // https://github.com/ant-design/ant-design/issues/9204
            if (!this.pressingUpOrDown) {
                return;
            }
            if (this.props.focusOnUpDown && this.state.focused) {
                var selectionRange = this.input.setSelectionRange;
                if (selectionRange && typeof selectionRange === 'function' && this.start !== undefined && this.end !== undefined) {
                    this.input.setSelectionRange(this.start, this.end);
                } else {
                    this.focus();
                }
                this.pressingUpOrDown = false;
            }
        }
    }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
            this.stop();
        }
    }, {
        key: 'getCurrentValidValue',
        value: function getCurrentValidValue(value) {
            var val = value;
            if (val === '') {
                val = '';
            } else if (!this.isNotCompleteNumber(val)) {
                val = this.getValidValue(val);
            } else {
                val = this.state.value;
            }
            return this.props.computeValidNumber(this.toNumber(val));
        }
    }, {
        key: 'getRatio',
        value: function getRatio(e) {
            var ratio = 1;
            if (e.metaKey || e.ctrlKey) {
                ratio = 0.1;
            } else if (e.shiftKey) {
                ratio = 10;
            }
            return ratio;
        }
    }, {
        key: 'getValueFromEvent',
        value: function getValueFromEvent(e) {
            return e.target.value.trim().replace(/。/g, '.');
        }
    }, {
        key: 'getValidValue',
        value: function getValidValue(value) {
            var min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.props.min;
            var max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.props.max;

            var val = parseFloat(value, 10);
            // https://github.com/ant-design/ant-design/issues/7358
            if (isNaN(val)) {
                return value;
            }
            if (val < min) {
                val = min;
            }
            if (val > max) {
                val = max;
            }
            return val;
        }
    }, {
        key: 'setValue',
        value: function setValue(v, callback) {
            // trigger onChange
            var newValue = this.isNotCompleteNumber(parseFloat(v, 10)) ? undefined : parseFloat(v, 10);
            var changed = newValue !== this.state.value || '' + newValue !== '' + this.state.inputValue; // https://github.com/ant-design/ant-design/issues/7363
            if (!('value' in this.props)) {
                this.setState({
                    value: newValue,
                    inputValue: this.toPrecisionAsStep(v)
                }, callback);
            } else {
                // always set input value same as value
                this.setState({
                    inputValue: this.toPrecisionAsStep(this.state.value)
                }, callback);
            }
            if (changed) {
                this.props.onChange(newValue);
            }
        }
    }, {
        key: 'getPrecision',
        value: function getPrecision(value) {
            if ('precision' in this.props) {
                return this.props.precision;
            }
            var valueString = value.toString();
            if (valueString.indexOf('e-') >= 0) {
                return parseInt(valueString.slice(valueString.indexOf('e-') + 2), 10);
            }
            var precision = 0;
            if (valueString.indexOf('.') >= 0) {
                precision = valueString.length - valueString.indexOf('.') - 1;
            }
            return precision;
        }

        // step={1.0} value={1.51}
        // press +
        // then value should be 2.51, rather than 2.5
        // if this.props.precision is undefined
        // https://github.com/react-component/input-number/issues/39

    }, {
        key: 'getMaxPrecision',
        value: function getMaxPrecision(currentValue) {
            var ratio = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

            if ('precision' in this.props) {
                return this.props.precision;
            }
            var step = this.props.step;

            var ratioPrecision = this.getPrecision(ratio);
            var stepPrecision = this.getPrecision(step);
            var currentValuePrecision = this.getPrecision(currentValue);
            if (!currentValue) {
                return ratioPrecision + stepPrecision;
            }
            return Math.max(currentValuePrecision, ratioPrecision + stepPrecision);
        }
    }, {
        key: 'getPrecisionFactor',
        value: function getPrecisionFactor(currentValue) {
            var ratio = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

            var precision = this.getMaxPrecision(currentValue, ratio);
            return Math.pow(10, precision);
        }
    }, {
        key: 'focus',
        value: function focus() {
            this.input.focus();
        }
    }, {
        key: 'blur',
        value: function blur() {
            this.input.blur();
        }
    }, {
        key: 'formatWrapper',
        value: function formatWrapper(num) {
            if (this.props.formatter) {
                return this.props.formatter(num);
            }
            return num;
        }
    }, {
        key: 'toPrecisionAsStep',
        value: function toPrecisionAsStep(num) {
            if (this.isNotCompleteNumber(num) || num === '') {
                return num;
            }
            var precision = Math.abs(this.getMaxPrecision(num));
            if (precision === 0) {
                return num.toString();
            }
            if (!isNaN(precision)) {
                return Number(num).toFixed(precision);
            }
            return num.toString();
        }

        // '1.' '1x' 'xx' '' => are not complete numbers

    }, {
        key: 'isNotCompleteNumber',
        value: function isNotCompleteNumber(num) {
            return isNaN(num) || num === '' || num === null || num && num.toString().indexOf('.') === num.toString().length - 1;
        }
    }, {
        key: 'toNumber',
        value: function toNumber(num) {
            if (this.isNotCompleteNumber(num)) {
                return num;
            }
            if ('precision' in this.props) {
                return Number(Number(num).toFixed(this.props.precision));
            }
            return Number(num);
        }

        // '1.0' '1.00'  => may be a inputing number

    }, {
        key: 'toNumberWhenUserInput',
        value: function toNumberWhenUserInput(num) {
            // num.length > 16 => prevent input large number will became Infinity
            if ((/\.\d*0$/.test(num) || num.length > 16) && this.state.focused) {
                return num;
            }
            return this.toNumber(num);
        }
    }, {
        key: 'upStep',
        value: function upStep(val, rat) {
            var _props = this.props,
                step = _props.step,
                upStep = _props.upStep,
                min = _props.min;

            var precisionFactor = this.getPrecisionFactor(val, rat);
            var precision = Math.abs(this.getMaxPrecision(val, rat));
            if (upStep != null) {
                step = upStep;
            }
            var result = void 0;
            if (typeof val === 'number') {
                result = ((precisionFactor * val + precisionFactor * step * rat) / precisionFactor).toFixed(precision);
            } else {
                result = min === -Infinity ? step : min;
            }
            return this.toNumber(result);
        }
    }, {
        key: 'downStep',
        value: function downStep(val, rat) {
            var _props2 = this.props,
                step = _props2.step,
                downStep = _props2.downStep,
                min = _props2.min;

            var precisionFactor = this.getPrecisionFactor(val, rat);
            var precision = Math.abs(this.getMaxPrecision(val, rat));
            if (downStep != null) {
                step = downStep;
            }
            var result = void 0;
            if (typeof val === 'number') {
                result = ((precisionFactor * val - precisionFactor * step * rat) / precisionFactor).toFixed(precision);
            } else {
                result = min === -Infinity ? -step : min;
            }
            return this.toNumber(result);
        }
    }, {
        key: 'step',
        value: function step(type, e) {
            var _this2 = this;

            var ratio = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
            var recursive = arguments[3];

            this.stop();
            if (e) {
                e.persist();
                e.preventDefault();
            }
            var props = this.props;
            if (props.disabled) {
                return;
            }
            var value = this.toNumber(this.state.inputValue || 0);
            if (this.isNotCompleteNumber(value)) {
                return;
            }
            var val = this[type + 'Step'](value, ratio);
            var outOfRange = val > props.max || val < props.min;
            if (val > props.max) {
                val = props.max;
            } else if (val < props.min) {
                val = props.min;
            }
            if (outOfRange) {
                return;
            }
            this.setValue(this.getCurrentValidValue(val), function () {
                return _this2.props.onNumberChange(val);
            });
            this.autoStepTimer = setTimeout(function () {
                _this2[type](e, ratio, true);
            }, recursive ? SPEED : DELAY);
        }
    }, {
        key: 'render',
        value: function render() {
            var _props3 = this.props,
                disabled = _props3.disabled,
                className = _props3.className,
                style = _props3.style,
                styleType = _props3.styleType,
                hideHandler = _props3.hideHandler,
                size = _props3.size;
            var focused = this.state.focused;


            return _react2.default.createElement(
                _style.NumberInputWrap,
                {
                    focused: focused,
                    disabled: disabled,
                    hideHandler: hideHandler,
                    size: size,
                    styleType: styleType,
                    style: style,
                    className: className
                },
                this.renderHandler(),
                this.renderInput()
            );
        }
    }]);

    return NumberInput;
}(_react.Component), _class.propTypes = {
    /** 值，受控 */
    value: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.string]),
    /** 默认值，非受控 */
    defaultValue: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.string]),
    /** @ignore */
    focusOnUpDown: _propTypes2.default.bool,
    /** @ignore */
    autoFocus: _propTypes2.default.bool,
    /** 修改回调 */
    onChange: _propTypes2.default.func,
    /**
     * 有效的修改回调，使用按钮改变值或者输入、回车后失焦时触发，可防止监听到无效的回调
     * @param value - 当前的值，必为有效数字
     */
    onNumberChange: _propTypes2.default.func,
    /** @ignore */
    onKeyDown: _propTypes2.default.func,
    /** @ignore */
    onKeyUp: _propTypes2.default.func,
    /** @ignore */
    onEnter: _propTypes2.default.func,
    /** 禁用 */
    disabled: _propTypes2.default.bool,
    /** @ignore */
    onFocus: _propTypes2.default.func,
    /** @ignore */
    onBlur: _propTypes2.default.func,
    /** 只读 */
    readOnly: _propTypes2.default.bool,
    /** 最大值 */
    max: _propTypes2.default.number,
    /** 最小值 */
    min: _propTypes2.default.number,
    /** 按钮每次变动大小 */
    step: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.string]),
    /** @ignore */
    upStep: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.string]),
    /** @ignore */
    downStep: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.string]),
    /** 自定义'+'按钮 */
    upHandler: _propTypes2.default.node,
    /** 自定义'-'按钮 */
    downHandler: _propTypes2.default.node,
    /** 定义数值展示格式化 */
    formatter: _propTypes2.default.func,
    /** 定义输入内容过滤 */
    parser: _propTypes2.default.func,
    /** 精度，小数点位数 */
    precision: _propTypes2.default.number,
    /** @ignore */
    className: _propTypes2.default.string,
    /** @ignore */
    style: _propTypes2.default.object,
    /** 样式风格 */
    styleType: _propTypes2.default.oneOf(StyleType),
    /** 尺寸 */
    size: _propTypes2.default.oneOf(Size),
    /** 自定义后缀 */
    suffix: _propTypes2.default.node,
    /** input框自定义样式 */
    inputStyle: _propTypes2.default.object,
    /** 计算合法值 */
    computeValidNumber: _propTypes2.default.func,
    /** 是否隐藏操作按钮 */
    hideHandler: _propTypes2.default.bool,
    /**
     * 输入提示，hover 和输入焦点时显示，可直接传入 tooltip 内容，或传入 tooltip 的 props，props 参考 tooltip 组件文档
     * 注意，如果使用自定义 props 中的 visible 和 onVisibleChange 则需要自己去控制 tooltip 的显示隐藏
     */
    tooltip: _propTypes2.default.oneOfType([_propTypes2.default.node, _propTypes2.default.object])
}, _class.defaultProps = {
    focusOnUpDown: true,
    min: -MAX_SAFE_INTEGER,
    step: 1,
    onChange: noop,
    onNumberChange: noop,
    onKeyDown: noop,
    onEnter: noop,
    onFocus: noop,
    onBlur: noop,
    parser: defaultParser,
    styleType: StyleType[0],
    size: 'md',
    computeValidNumber: function computeValidNumber(v) {
        return v;
    }
}, _initialiseProps = function _initialiseProps() {
    var _this3 = this;

    this.onKeyDown = function (e) {
        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
        }

        if (e.keyCode === _KeyCode2.default['ARROW_UP']) {
            var ratio = _this3.getRatio(e);
            _this3.up(e, ratio);
            _this3.stop();
        } else if (e.keyCode === _KeyCode2.default['ARROW_DOWN']) {
            var _ratio = _this3.getRatio(e);
            _this3.down(e, _ratio);
            _this3.stop();
        } else if (e.keyCode === _KeyCode2.default['ENTER']) {
            _this3.onEnter.apply(_this3, [e].concat(args));
        }
        var onKeyDown = _this3.props.onKeyDown;

        if (onKeyDown) {
            onKeyDown.apply(undefined, [e].concat(args));
        }
    };

    this.onKeyUp = function (e) {
        for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
        }

        _this3.stop();
        var onKeyUp = _this3.props.onKeyUp;

        if (onKeyUp) {
            onKeyUp.apply(undefined, [e].concat(args));
        }
    };

    this.onChange = function (e) {
        if (_this3.state.focused) {
            _this3.inputting = true;
        }
        var input = _this3.props.parser(_this3.getValueFromEvent(e));
        _this3.setState({ inputValue: input });
        _this3.props.onChange(_this3.toNumberWhenUserInput(input)); // valid number or invalid string
    };

    this.onFocus = function () {
        var _props4;

        _this3.setState({
            focused: true
        });
        (_props4 = _this3.props).onFocus.apply(_props4, arguments);
    };

    this.onBlur = function (e) {
        for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
            args[_key3 - 1] = arguments[_key3];
        }

        _this3.inputting = false;
        _this3.setState({
            focused: false
        });
        var value = _this3.getCurrentValidValue(_this3.state.inputValue);
        e.persist(); // fix https://github.com/react-component/input-number/issues/51
        _this3.setValue(value, function () {
            var _props5;

            (_props5 = _this3.props).onBlur.apply(_props5, [e].concat(args));
            _this3.props.onNumberChange(value);
        });
    };

    this.onEnter = function (e) {
        for (var _len4 = arguments.length, args = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
            args[_key4 - 1] = arguments[_key4];
        }

        var value = _this3.getCurrentValidValue(_this3.state.inputValue);
        if (e) {
            e.persist();
            e.preventDefault();
        }
        _this3.setValue(value, function () {
            var _props6;

            (_props6 = _this3.props).onEnter.apply(_props6, [e].concat(args));
            _this3.props.onNumberChange(value);
        });
    };

    this.stop = function () {
        if (_this3.autoStepTimer) {
            clearTimeout(_this3.autoStepTimer);
        }
    };

    this.down = function (e, ratio, recursive) {
        _this3.pressingUpOrDown = true;
        _this3.step('down', e, ratio, recursive);
    };

    this.up = function (e, ratio, recursive) {
        _this3.pressingUpOrDown = true;
        _this3.step('up', e, ratio, recursive);
    };

    this.saveInput = function (node) {
        _this3.input = node;
    };

    this.renderHandler = function () {
        var _props7 = _this3.props,
            upHandler = _props7.upHandler,
            downHandler = _props7.downHandler,
            readOnly = _props7.readOnly,
            max = _props7.max,
            min = _props7.min,
            disabled = _props7.disabled,
            styleType = _props7.styleType,
            hideHandler = _props7.hideHandler;

        if (hideHandler) return null;

        var value = _this3.state.value;

        var editable = !readOnly && !disabled;
        var upDisabled = void 0;
        var downDisabled = void 0;
        if (value || value === 0) {
            if (!isNaN(value)) {
                var val = Number(value);
                if (val >= max) {
                    upDisabled = true;
                }
                if (val <= min) {
                    downDisabled = true;
                }
            } else {
                upDisabled = true;
                downDisabled = true;
            }
        }
        var upEvents = void 0;
        var downEvents = void 0;

        upEvents = {
            onMouseDown: function onMouseDown(e) {
                return editable && !upDisabled ? _this3.up(e) : noop();
            },
            onMouseUp: function onMouseUp(e) {
                return _this3.stop(e);
            },
            onMouseLeave: function onMouseLeave(e) {
                return _this3.stop(e);
            }
        };
        downEvents = {
            onMouseDown: function onMouseDown(e) {
                return editable && !downDisabled ? _this3.down(e) : noop();
            },
            onMouseUp: function onMouseUp(e) {
                return _this3.stop(e);
            },
            onMouseLeave: function onMouseLeave(e) {
                return _this3.stop(e);
            }
        };

        return _react2.default.createElement(
            'div',
            null,
            _react2.default.createElement(
                _style.HandlerUp,
                _extends({ unselectable: 'unselectable', disabled: disabled || upDisabled }, upEvents),
                upHandler || _react2.default.createElement(_Icon2.default, {
                    type: {
                        default: 'caret-up',
                        split: 'plus',
                        pagination: 'right'
                    }[styleType]
                })
            ),
            _react2.default.createElement(
                _style.HandlerDown,
                _extends({ unselectable: 'unselectable', disabled: disabled || downDisabled }, downEvents),
                downHandler || _react2.default.createElement(_Icon2.default, {
                    type: {
                        default: 'caret-down',
                        split: 'minus',
                        pagination: 'left'
                    }[styleType]
                })
            )
        );
    };

    this.onTooltipVisibleChange = function (visible) {
        _this3.setState({
            tooltipVisible: visible
        });
    };

    this.renderInput = function () {
        /* eslint-disable no-unused-vars */
        var _props8 = _this3.props,
            disabled = _props8.disabled,
            className = _props8.className,
            readOnly = _props8.readOnly,
            style = _props8.style,
            defaultValue = _props8.defaultValue,
            focusOnUpDown = _props8.focusOnUpDown,
            onChange = _props8.onChange,
            onFocus = _props8.onFocus,
            onBlur = _props8.onBlur,
            upHandler = _props8.upHandler,
            downHandler = _props8.downHandler,
            formatter = _props8.formatter,
            parser = _props8.parser,
            precision = _props8.precision,
            styleType = _props8.styleType,
            suffix = _props8.suffix,
            inputStyle = _props8.inputStyle,
            onNumberChange = _props8.onNumberChange,
            computeValidNumber = _props8.computeValidNumber,
            hideHandler = _props8.hideHandler,
            size = _props8.size,
            tooltip = _props8.tooltip,
            rest = _objectWithoutProperties(_props8, ['disabled', 'className', 'readOnly', 'style', 'defaultValue', 'focusOnUpDown', 'onChange', 'onFocus', 'onBlur', 'upHandler', 'downHandler', 'formatter', 'parser', 'precision', 'styleType', 'suffix', 'inputStyle', 'onNumberChange', 'computeValidNumber', 'hideHandler', 'size', 'tooltip']);
        /* eslint-enable no-unused-vars */

        var _state = _this3.state,
            focused = _state.focused,
            inputValue = _state.inputValue,
            value = _state.value,
            tooltipVisible = _state.tooltipVisible;

        // focus state, show input value
        // unfocus state, show valid value

        var inputDisplayValue = void 0;
        if (focused) {
            inputDisplayValue = inputValue;
        } else {
            inputDisplayValue = _this3.toPrecisionAsStep(value);
        }

        if (inputDisplayValue === undefined || inputDisplayValue === null) {
            inputDisplayValue = '';
        }

        var inputDisplayValueFormat = _this3.formatWrapper(inputDisplayValue);
        var editable = !readOnly && !disabled;
        var input = _react2.default.createElement(
            _style.InputWrap,
            null,
            _react2.default.createElement(_style.Input, _extends({}, rest, {
                size: size,
                autoComplete: 'off',
                onFocus: _this3.onFocus,
                onBlur: _this3.onBlur,
                onKeyDown: editable ? _this3.onKeyDown : noop,
                onKeyUp: editable ? _this3.onKeyUp : noop,
                onChange: _this3.onChange,
                disabled: disabled,
                readOnly: readOnly,
                innerRef: _this3.saveInput,
                value: inputDisplayValueFormat,
                style: inputStyle
            })),
            suffix && _react2.default.createElement(
                _style.InputSuffix,
                null,
                suffix
            )
        );

        if (!tooltip) {
            return input;
        } else if (typeof tooltip === 'string' || _react2.default.isValidElement(tooltip)) {
            return _react2.default.createElement(
                _Tooltip2.default,
                {
                    popup: tooltip,
                    visible: focused || tooltipVisible,
                    onVisibleChange: _this3.onTooltipVisibleChange
                },
                input
            );
        } else if ((0, _isObject3.default)(tooltip)) {
            return _react2.default.createElement(
                _Tooltip2.default,
                _extends({ visible: focused || tooltipVisible, onVisibleChange: _this3.onTooltipVisibleChange }, tooltip),
                input
            );
        } else {
            return input;
        }
    };
}, _temp);


NumberInput.StyleType = StyleType;
NumberInput.Size = Size;
exports.default = NumberInput;