'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _isNaN2 = require('lodash/isNaN');

var _isNaN3 = _interopRequireDefault(_isNaN2);

var _find2 = require('lodash/find');

var _find3 = _interopRequireDefault(_find2);

var _isObject2 = require('lodash/isObject');

var _isObject3 = _interopRequireDefault(_isObject2);

var _each2 = require('lodash/each');

var _each3 = _interopRequireDefault(_each2);

var _keys2 = require('lodash/keys');

var _keys3 = _interopRequireDefault(_keys2);

var _sortBy2 = require('lodash/sortBy');

var _sortBy3 = _interopRequireDefault(_sortBy2);

var _isEmpty2 = require('lodash/isEmpty');

var _isEmpty3 = _interopRequireDefault(_isEmpty2);

var _isEqual2 = require('lodash/isEqual');

var _isEqual3 = _interopRequireDefault(_isEqual2);

var _isFunction2 = require('lodash/isFunction');

var _isFunction3 = _interopRequireDefault(_isFunction2);

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _dec, _dec2, _class, _class2, _temp, _initialiseProps;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _rcSlider = require('rc-slider');

var _rcSlider2 = _interopRequireDefault(_rcSlider);

var _Tooltip = require('../Tooltip');

var _Tooltip2 = _interopRequireDefault(_Tooltip);

var _NumberInput = require('../NumberInput');

var _NumberInput2 = _interopRequireDefault(_NumberInput);

var _uncontrolled = require('../../decorators/uncontrolled');

var _uncontrolled2 = _interopRequireDefault(_uncontrolled);

var _localeConsumerDecorator = require('../../components/LocaleProvider/localeConsumerDecorator');

var _localeConsumerDecorator2 = _interopRequireDefault(_localeConsumerDecorator);

var _style = require('./style');

var _zh_CN = require('./locale/zh_CN');

var _zh_CN2 = _interopRequireDefault(_zh_CN);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var Handle = _rcSlider2.default.Handle;

var Size = ['sm', 'md', 'lg'];

var _handle = function _handle(props) {
    var value = props.value,
        dragging = props.dragging,
        index = props.index,
        tipFormatter = props.tipFormatter,
        restProps = _objectWithoutProperties(props, ['value', 'dragging', 'index', 'tipFormatter']);

    return _react2.default.createElement(
        _Tooltip2.default,
        {
            popupClassName: _style.prefixCls + '-tooltip',
            popup: (0, _isFunction3.default)(tipFormatter) ? tipFormatter(value) : value == null ? '' : value,
            visible: dragging && tipFormatter !== null,
            placement: 'top',
            key: index,
            theme: 'dark',
            getPopupContainer: function getPopupContainer(triggerNode) {
                return triggerNode;
            }
        },
        _react2.default.createElement(Handle, _extends({ value: value }, restProps))
    );
};
_handle.propTypes = {
    value: _propTypes2.default.number,
    dragging: _propTypes2.default.bool,
    index: _propTypes2.default.number,
    tipFormatter: _propTypes2.default.func
};

var getPrecision = function getPrecision(n) {
    var valueString = n.toString();
    if (valueString.indexOf('e-') >= 0) {
        return parseInt(valueString.slice(valueString.indexOf('e-') + 2), 10);
    }
    var precision = 0;
    if (valueString.indexOf('.') >= 0) {
        precision = valueString.length - valueString.indexOf('.') - 1;
    }
    return precision;
};

var sliderSplit = 300;

var Slider = (_dec = (0, _localeConsumerDecorator2.default)({ defaultLocale: _zh_CN2.default, localeName: 'Slider' }), _dec2 = (0, _uncontrolled2.default)({}), _dec(_class = _dec2(_class = (_temp = _class2 = function (_Component) {
    _inherits(Slider, _Component);

    function Slider(props) {
        _classCallCheck(this, Slider);

        var _this = _possibleConstructorReturn(this, (Slider.__proto__ || Object.getPrototypeOf(Slider)).call(this, props));

        _initialiseProps.call(_this);

        _this.state = {};
        _this.state.cacheMarks = _this.simpleClone(props.marks);
        _this.state.marks = _this.computeMarks(props.marks, props);
        _this.state.marksForSlider = _this.computeMarksForSlider(_this.state.marks, props);
        _this.resetCache();
        return _this;
    }

    _createClass(Slider, [{
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            if (!(nextProps.marks == this.state.cacheMarks || (0, _isEqual3.default)(nextProps.marks, this.state.cacheMarks)) || nextProps.max !== this.props.max || nextProps.min !== this.props.min || nextProps.step !== this.props.step) {
                var marks = this.computeMarks(nextProps.marks, nextProps);
                this.setState({
                    cacheMarks: this.simpleClone(nextProps.marks),
                    marks: marks,
                    marksForSlider: this.computeMarksForSlider(marks, nextProps)
                });
                this.resetCache();
            }
        }
    }, {
        key: 'render',
        value: function render() {
            var _this2 = this;

            /* eslint-disable no-unused-vars */
            var _props = this.props,
                value = _props.value,
                defaultValue = _props.defaultValue,
                onChange = _props.onChange,
                className = _props.className,
                style = _props.style,
                disabled = _props.disabled,
                min = _props.min,
                max = _props.max,
                step = _props.step,
                sliderClassName = _props.sliderClassName,
                sliderStyle = _props.sliderStyle,
                _inputProps = _props.numberInput,
                numberInputTipFormatter = _props.numberInputTipFormatter,
                tipFormatter = _props.tipFormatter,
                size = _props.size,
                _marks = _props.marks,
                isSensitive = _props.isSensitive,
                locale = _props.locale,
                onLastChange = _props.onLastChange,
                rest = _objectWithoutProperties(_props, ['value', 'defaultValue', 'onChange', 'className', 'style', 'disabled', 'min', 'max', 'step', 'sliderClassName', 'sliderStyle', 'numberInput', 'numberInputTipFormatter', 'tipFormatter', 'size', 'marks', 'isSensitive', 'locale', 'onLastChange']);
            /* eslint-enable no-unused-vars */


            var _state = this.state,
                marksForSlider = _state.marksForSlider,
                isNumberInputFocused = _state.isNumberInputFocused,
                numberInputValue = _state.numberInputValue;

            var sharingProps = {
                disabled: disabled
            };
            var sliderProps = Object.assign({}, rest, {
                className: sliderClassName,
                style: sliderStyle,
                onChange: this.onSliderChange,
                onAfterChange: function onAfterChange() {
                    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                        args[_key] = arguments[_key];
                    }

                    return _this2.onSliderChange.apply(_this2, args.concat([true]));
                }
            });
            var inputProps = Object.assign({}, _inputProps, {
                min: min,
                max: max,
                size: size,
                value: isNumberInputFocused ? numberInputValue : value
            }, this.getValueStep(value), {
                onChange: this.onNumberInputChange,
                onNumberChange: this.onNumberInputNumberChange,
                onFocus: this.onNumberInputFocus,
                onBlur: this.onNumberInputBlur,
                computeValidNumber: this.translateNumberInputValueToValue
            });
            var isNumberInputValid = numberInputValue + '' === value + '';
            return _react2.default.createElement(
                _style.SliderWrap,
                { disabled: disabled, style: style, className: className, size: size },
                _react2.default.createElement(
                    _style.RcSliderWrap,
                    null,
                    _react2.default.createElement(_rcSlider2.default, _extends({
                        min: 0,
                        max: sliderSplit,
                        step: 1,
                        value: this.translateValueToSliderValue(value),
                        prefixCls: _style.prefixCls,
                        handle: function handle(handleProps) {
                            return _handle(Object.assign({}, handleProps, {
                                value: value,
                                tipFormatter: tipFormatter
                            }));
                        },
                        marks: marksForSlider || {}
                    }, sliderProps, sharingProps))
                ),
                _inputProps === null ? null : _react2.default.createElement(
                    _Tooltip2.default,
                    {
                        popupClassName: _style.prefixCls + '-tooltip',
                        popup: (0, _isFunction3.default)(numberInputTipFormatter) ? numberInputTipFormatter({
                            currentValue: value,
                            inputValue: numberInputValue,
                            isSensitive: isSensitive,
                            locale: locale
                        }) : '' + locale.currentValueIs + value + locale.comma + locale.inputValueIs + numberInputValue + (isSensitive ? '' + locale.comma + locale.input + (isNumberInputValid ? locale.isValid : locale.isUnvalid) + (isNumberInputValid ? '' : '' + locale.comma + locale.tip) : ''),
                        visible: isNumberInputFocused && numberInputTipFormatter !== null,
                        placement: 'top',
                        theme: 'dark',
                        getPopupContainer: function getPopupContainer(triggerNode) {
                            return triggerNode.parentNode;
                        }
                    },
                    _react2.default.createElement(_NumberInput2.default, _extends({}, inputProps, sharingProps))
                )
            );
        }
    }]);

    return Slider;
}(_react.Component), _class2.propTypes = {
    /** 值，受控 */
    value: _propTypes2.default.number,
    /** 默认值，非受控 */
    defaultValue: _propTypes2.default.number,
    /** 修改回调 */
    onChange: _propTypes2.default.func,
    /** 拖拽结束、输入回车、输入失焦、数字输入框上下按钮等时触发 */
    onLastChange: _propTypes2.default.func,
    /** 是否禁用 */
    disabled: _propTypes2.default.bool,
    /** 最小值 */
    min: _propTypes2.default.number,
    /** 最大值 */
    max: _propTypes2.default.number,
    /** 每次变动的大小，传入的(最大值-最小值)必须为step的整数倍，大于0 */
    step: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.string]),
    /** 标记 */
    marks: _propTypes2.default.object,
    /** @ignore */
    className: _propTypes2.default.string,
    /** @ignore */
    style: _propTypes2.default.object,
    /** slider 类名 */
    sliderClassName: _propTypes2.default.string,
    /** slider 样式 */
    sliderStyle: _propTypes2.default.object,
    /** number input 的自定义 props，为null时隐藏 */
    numberInput: _propTypes2.default.object,
    /** 是否灵敏的触发onChange，为true时当NumberInput中事实输入有效值时会触发onChange */
    isSensitive: _propTypes2.default.bool,
    /**
     * 输入框提示语格式化，传入null隐藏
     * @param option - 包含当前值、生效值等
     */
    numberInputTipFormatter: _propTypes2.default.func,
    /**
     * 提示语格式化，传入null隐藏
     * @param value - 当前值
     */
    tipFormatter: _propTypes2.default.func,
    /** 尺寸 */
    size: _propTypes2.default.oneOf(Size),
    /** @ignore */
    locale: _propTypes2.default.object
}, _class2.defaultProps = {
    onChange: function onChange() {},
    onLastChange: function onLastChange() {},
    defaultValue: 0,
    step: 1,
    size: 'md',
    min: 0,
    max: 100
}, _initialiseProps = function _initialiseProps() {
    var _this3 = this;

    this.simpleClone = function () {
        var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

        return JSON.parse(JSON.stringify(obj));
    };

    this.resetCache = function () {
        _this3.cache = {
            valueToSliderValueMap: {},
            sliderValueToValueMap: {},
            numberInputValueToValueMap: {},
            valueToValueStepMap: {}
        };
    };

    this.computeMarks = function (_marks, props) {
        if ((0, _isEmpty3.default)(_marks)) {
            return null;
        }
        var min = props.min,
            max = props.max,
            step = props.step;

        var values = (0, _sortBy3.default)((0, _keys3.default)(_marks), function (v) {
            return +v;
        });
        var l = values.length;
        var marks = [];
        var indexWithRatio = [];
        var indexWithoutRatio = [];
        var usedRatio = 0;
        var usedRange = 0;
        if (+values[l - 1] !== +max) {
            values.push(max);
        }
        (0, _each3.default)(values, function (v, i) {
            var info = _marks[v];
            v = +v;
            if (!(0, _isObject3.default)(info)) {
                info = {
                    label: info
                };
            } else {
                info = Object.assign({}, info);
            }
            var range = [];
            if (i === 0) {
                range[0] = min;
            } else {
                range[0] = +values[i - 1];
            }
            range[1] = v;
            info.range = range;
            info.value = v;
            marks.push(info);
            if (info.ratio) {
                indexWithRatio.push(i);
                usedRatio += info.ratio;
                usedRange += range[1] - range[0];
            } else {
                indexWithoutRatio.push(i);
            }
            if (!('step' in info)) {
                info.step = step;
            }
        });
        var remainRange = max - min - usedRange;
        (0, _each3.default)(indexWithoutRatio, function (i) {
            var info = marks[i];
            info.ratio = (info.range[1] - info.range[0]) / remainRange * (100 - usedRatio);
        });
        var ratioBefore = 0;
        (0, _each3.default)(marks, function (mark) {
            mark.ratioBefore = ratioBefore;
            ratioBefore += mark.ratio;
        });
        return marks;
    };

    this.computeMarksForSlider = function (_marks, props) {
        if ((0, _isEmpty3.default)(_marks)) {
            return null;
        }
        var max = props.max;

        var marks = {};
        var baseRatio = 0;
        (0, _each3.default)(_marks, function (_mark) {
            if (_mark.label == null) {
                return;
            }
            var value = (baseRatio += _mark.ratio) / 100 * sliderSplit;
            var mark = {
                label: _mark.label,
                style: Object.assign({
                    transform: 'none'
                }, _mark.value == max ? { borderRight: 'none' } : {}, _mark.style)
            };
            marks[value] = mark;
        });
        return marks;
    };

    this.handleChange = function (v, lastest) {
        var _props2 = _this3.props,
            onChange = _props2.onChange,
            onLastChange = _props2.onLastChange,
            value = _props2.value;

        if (v + '' !== value + '') {
            onChange(v);
        }
        if (lastest) {
            onLastChange(v);
        }
    };

    this.onNumberInputNumberChange = function (v) {
        _this3.handleChange(v, true);
    };

    this.onNumberInputChange = function (v) {
        var isSensitive = _this3.props.isSensitive;

        if (isSensitive) {
            var validValue = _this3.translateNumberInputValueToValue(v);
            if (validValue + '' === v + '') {
                _this3.handleChange(v);
            }
        }
        _this3.setState({
            numberInputValue: v
        });
    };

    this.onNumberInputFocus = function () {
        _this3.setState({
            numberInputValue: _this3.props.value,
            isNumberInputFocused: true
        });
    };

    this.onNumberInputBlur = function () {
        _this3.setState({
            isNumberInputFocused: false
        });
    };

    this.onSliderChange = function (v, lastest) {
        var value = _this3.translateSliderValueToValue(v);
        _this3.handleChange(value, lastest);
    };

    this.translateSliderValueToValue = function (v) {
        if (v in _this3.cache.sliderValueToValueMap) {
            return _this3.cache.sliderValueToValueMap[v];
        }
        var marks = _this3.state.marks;
        var _props3 = _this3.props,
            min = _props3.min,
            max = _props3.max,
            step = _props3.step;

        var value = void 0;
        if ((0, _isEmpty3.default)(marks)) {
            value = _this3.computeValidNumber(min + (max - min) * v / sliderSplit, {
                step: step,
                min: min,
                max: max
            });
        } else if (v == sliderSplit) {
            value = max;
        } else {
            var vRatio = v / sliderSplit * 100;
            var mark = (0, _find3.default)(marks, function (mark) {
                var ratioBefore = mark.ratioBefore,
                    ratio = mark.ratio;

                if (vRatio >= ratioBefore && vRatio < ratioBefore + ratio) {
                    return true;
                }
            });
            if (!mark) mark = marks[0];
            var _mark2 = mark,
                ratioBefore = _mark2.ratioBefore,
                range = _mark2.range,
                ratio = _mark2.ratio,
                _step = _mark2.step;

            value = _this3.computeValidNumber((vRatio - ratioBefore) / ratio * (range[1] - range[0]) + range[0], {
                min: range[0],
                max: range[1],
                step: _step
            });
        }
        _this3.cache.sliderValueToValueMap[v] = value;
        return value;
    };

    this.translateValueToSliderValue = function (v) {
        if (v in _this3.cache.valueToSliderValueMap) {
            return _this3.cache.valueToSliderValueMap[v];
        }
        var marks = _this3.state.marks;
        var _props4 = _this3.props,
            min = _props4.min,
            max = _props4.max;

        var value = void 0;
        if (v == undefined) {
            value = 0;
        } else if ((0, _isEmpty3.default)(marks)) {
            value = (v - min) / (max - min) * sliderSplit;
        } else if (v == max) {
            value = sliderSplit;
        } else {
            var mark = (0, _find3.default)(marks, function (mark) {
                var range = mark.range;

                if (v >= range[0] && v < range[1]) {
                    return true;
                }
            });
            if (!mark) mark = marks[0];
            var _mark3 = mark,
                range = _mark3.range,
                ratio = _mark3.ratio,
                ratioBefore = _mark3.ratioBefore;

            value = ((v - range[0]) / (range[1] - range[0]) * ratio + ratioBefore) / 100 * sliderSplit;
        }
        _this3.cache.valueToSliderValueMap[v] = value;
        return value;
    };

    this.translateNumberInputValueToValue = function (v) {
        if (v in _this3.cache.numberInputValueToValueMap) {
            return _this3.cache.numberInputValueToValueMap[v];
        }
        var marks = _this3.state.marks;
        var _props5 = _this3.props,
            min = _props5.min,
            max = _props5.max,
            step = _props5.step;

        if (isNaN(v) || v + '' !== +v + '') {
            return min;
        }
        var value = void 0;
        if ((0, _isEmpty3.default)(marks)) {
            value = _this3.computeValidNumber(v, {
                step: step,
                min: min,
                max: max
            });
        } else if (v === max) {
            value = max;
        } else {
            var mark = marks[0];
            for (var i in marks) {
                i = +i;
                var _mark = marks[i];
                var _range = _mark.range;

                if (v >= _range[0] && v < _range[1]) {
                    mark = _mark;
                }
            }
            var _mark4 = mark,
                range = _mark4.range,
                _step2 = _mark4.step;

            value = _this3.computeValidNumber(v, {
                min: range[0],
                max: range[1],
                step: _step2
            });
        }
        _this3.cache.numberInputValueToValueMap[v] = value;
        return value;
    };

    this.getValueStep = function (v) {
        if (v in _this3.cache.valueToValueStepMap) {
            return _this3.cache.valueToValueStepMap[v];
        }
        var marks = _this3.state.marks;
        var step = _this3.props.step;

        var valueStep = { step: step };
        if (!(0, _isEmpty3.default)(marks)) {
            var l = marks.length;
            for (var i in marks) {
                i = +i;
                var mark = marks[i];
                var range = mark.range,
                    markStep = mark.step;

                if (+v === +range[0]) {
                    valueStep = {
                        upStep: markStep,
                        downStep: i > 0 ? marks[i - 1].step : step
                    };
                    break;
                } else if (v > range[0] && v < range[1]) {
                    valueStep = {
                        upStep: markStep,
                        downStep: markStep
                    };
                    break;
                } else if (+v === +range[1]) {
                    valueStep = {
                        upStep: i < l - 1 ? marks[i + 1].step : step,
                        downStep: markStep
                    };
                    break;
                }
            }
        }
        _this3.cache.valueToValueStepMap[v] = valueStep;
        return valueStep;
    };

    this.computeValidNumber = function (number, options) {
        var _ref = options || _this3.props,
            step = _ref.step,
            min = _ref.min,
            max = _ref.max;

        if (number < min) {
            return min;
        }
        if (number > max) {
            return max;
        }
        var stepPrecision = getPrecision(step);
        var maxPrecision = getPrecision(max);
        var minPrecision = getPrecision(min);
        var precision = Math.max(stepPrecision, maxPrecision, minPrecision);
        number = +(((number - min) / step).toFixed(0) * step + min).toFixed(precision);
        if (number < min) {
            return min;
        }
        if (number > max) {
            return max;
        }
        return (0, _isNaN3.default)(number) ? 0 : number;
    };
}, _temp)) || _class) || _class);

Slider.Size = Size;
exports.default = Slider;