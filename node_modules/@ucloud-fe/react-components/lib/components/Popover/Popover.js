'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.prefixCls = undefined;

var _debounce2 = require('lodash/debounce');

var _debounce3 = _interopRequireDefault(_debounce2);

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _class, _temp, _initialiseProps;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactLifecyclesCompat = require('react-lifecycles-compat');

var _placements = require('./placements');

var _placements2 = _interopRequireDefault(_placements);

var _style = require('./style');

var _ContainerContext = require('./ContainerContext');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Animation = ['fade', 'zoom', 'bounce', 'slide-up'];
var Trigger = ['hover', 'focus', 'click', 'contextMenu'];
var Placement = Object.keys(_placements2.default);

var Popover = (_temp = _class = function (_Component) {
    _inherits(Popover, _Component);

    function Popover(props) {
        _classCallCheck(this, Popover);

        var _this = _possibleConstructorReturn(this, (Popover.__proto__ || Object.getPrototypeOf(Popover)).call(this, props));

        _initialiseProps.call(_this);

        if ('visible' in props) {
            _this.state = {
                visible: props.visible
            };
        } else {
            _this.state = {
                visible: props.defaultVisible
            };
        }
        return _this;
    }

    _createClass(Popover, [{
        key: 'getPopup',
        value: function getPopup() {
            var popup = this.props.popup;

            return _react2.default.createElement(
                'div',
                { ref: this.bindPopupWrap },
                popup
            );
        }
    }, {
        key: 'getPopupDomNode',
        value: function getPopupDomNode() {
            return this.trigger.getPopupDomNode();
        }
    }, {
        key: 'render',
        value: function render() {
            var _this2 = this;

            var _props = this.props,
                children = _props.children,
                transitionName = _props.transitionName,
                animation = _props.animation,
                align = _props.align,
                placement = _props.placement,
                trigger = _props.trigger,
                _props$stretch = _props.stretch,
                stretch = _props$stretch === undefined ? [] : _props$stretch,
                className = _props.className,
                getPopupContainer = _props.getPopupContainer,
                forwardPopupContainer = _props.forwardPopupContainer,
                rest = _objectWithoutProperties(_props, ['children', 'transitionName', 'animation', 'align', 'placement', 'trigger', 'stretch', 'className', 'getPopupContainer', 'forwardPopupContainer']);

            var popup = this.getPopup();

            var renderPopover = function renderPopover(getPopupContainer) {
                return _react2.default.createElement(
                    _style.PopoverWrap,
                    _extends({}, rest, {
                        triggerRef: _this2.saveTrigger,
                        action: trigger,
                        popupPlacement: placement,
                        popupAlign: align,
                        popupTransitionName: transitionName || animation ? _style.animationPrefixCls + '-' + animation : null,
                        popupVisible: popup == null ? false : _this2.state.visible,
                        popup: popup,
                        onPopupVisibleChange: _this2.onVisibleChange,
                        stretch: stretch.join(''),
                        trueClassName: className,
                        getPopupContainer: getPopupContainer
                    }),
                    children
                );
            };
            return !getPopupContainer && forwardPopupContainer ? _react2.default.createElement(
                _ContainerContext.Consumer,
                null,
                function () {
                    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
                        getPopupContainerFromContext = _ref2.getPopupContainer;

                    return renderPopover(getPopupContainerFromContext || (typeof forwardPopupContainer === 'function' ? forwardPopupContainer : undefined));
                }
            ) : renderPopover(getPopupContainer);
        }
    }], [{
        key: 'getDerivedStateFromProps',
        value: function getDerivedStateFromProps(nextProps) {
            if ('visible' in nextProps) {
                return {
                    visible: nextProps.visible
                };
            }
            return null;
        }
    }]);

    return Popover;
}(_react.Component), _class.propTypes = {
    /** 受控，控制弹出层展示 */
    visible: _propTypes2.default.bool,
    /** 非受控，是否默认展示弹出层 */
    defaultVisible: _propTypes2.default.bool,
    /** 弹出层显示隐藏时触发 */
    onVisibleChange: _propTypes2.default.func,
    /** 如何触发弹出层，focus需要注意被包裹元素必须能触发focus事件，如链接、按钮、input等 */
    trigger: _propTypes2.default.arrayOf(_propTypes2.default.oneOf(Trigger)),
    /** 根据鼠标位置定位 */
    alignPoint: _propTypes2.default.bool,
    /** @ignore */
    showAction: _propTypes2.default.array,
    /** @ignore */
    hideAction: _propTypes2.default.array,
    /** 位置 */
    placement: _propTypes2.default.oneOf(Placement),
    /**
     * @ignore
     * 自定义定位配置
     */
    builtinPlacements: _propTypes2.default.object,
    /** 自定义定位 */
    align: _propTypes2.default.object,
    /** 尺寸自适应，'width', 'minWidth', 'height', 'minHeight' 或混合使用 */
    stretch: _propTypes2.default.arrayOf(_propTypes2.default.oneOf(['width', 'minWidth', 'height', 'minHeight'])),
    /** 弹出层内容 */
    popup: _propTypes2.default.node,
    /** 弹出层的类名 */
    popupClassName: _propTypes2.default.string,
    /** 弹出层的样式 */
    popupStyle: _propTypes2.default.object,
    /** 弹出层的z-index */
    zIndex: _propTypes2.default.number,
    /** 自定义弹出层容器 */
    getPopupContainer: _propTypes2.default.func,
    /** 是否使用最上层传入的安全容器，如果为 function，在没有找到安全容器时将会使用该 function 作为 getPopupContainer 的值 */
    forwardPopupContainer: _propTypes2.default.oneOfType([_propTypes2.default.bool, _propTypes2.default.func]),
    /**
     * @ignore
     * 自定义类名前缀
     */
    prefixCls: _propTypes2.default.string,
    /**
     * 需要对子元素进行定位，所以只接收一个有效 react 元素（不接收文本节点）
     */
    children: _propTypes2.default.element.isRequired,
    /** 动画名称，slide-up只支持上下方向的弹窗 */
    animation: _propTypes2.default.oneOf(Animation),
    /**
     * @ignore
     * 自定义动画
     */
    transitionName: _propTypes2.default.string,
    /**
     * 更新时强制重新定位
     * @ignore
     */
    forceAlignWhenUpdate: _propTypes2.default.bool,
    /** @ignore */
    className: _propTypes2.default.string
}, _class.defaultProps = {
    trigger: ['hover'],
    showAction: [],
    hideAction: [],
    popupClassName: '',
    animation: 'fade',
    popupStyle: {},
    defaultVisible: false,
    onVisibleChange: function onVisibleChange() {},

    placement: 'bottomLeft',
    builtinPlacements: _placements2.default,
    prefixCls: _style.prefixCls
}, _initialiseProps = function _initialiseProps() {
    var _this3 = this;

    this.__scroll_lock = false;

    this.bindPopupWrap = function (_ref) {
        if (_this3.popupWrap === _ref) return;
        if (_this3.popupWrap) {
            _this3.popupWrap.removeEventListener('scroll', _this3.onPopupWrapScroll, true);
        }
        _this3.popupWrap = _ref;
        if (_this3.popupWrap) {
            _this3.popupWrap.addEventListener('scroll', _this3.onPopupWrapScroll, true);
        }
    };

    this.onPopupWrapScroll = function () {
        _this3.__scroll_lock = true;
        _this3.unlockScroll();
    };

    this.unlockScroll = (0, _debounce3.default)(function () {
        _this3.__scroll_lock = false;
    }, 200);

    this.componentDidMount = function () {
        document.addEventListener('scroll', _this3.onScroll, true);
    };

    this.componentWillUnmount = function () {
        document.removeEventListener('scroll', _this3.onScroll, true);
    };

    this.onScroll = function () {
        if (_this3.__scroll_lock) return;
        _this3.forceAlign();
    };

    this.forceAlign = (0, _debounce3.default)(function () {
        if (_this3.__scroll_lock) return;
        _this3.trigger && _this3.trigger.forcePopupAlign();
    }, 33);

    this.componentDidUpdate = function () {
        _this3.props.forceAlignWhenUpdate && _this3.forceAlign();
    };

    this.onVisibleChange = function (visible) {
        var props = _this3.props;
        if (!('visible' in props)) {
            _this3.setState({
                visible: visible
            });
        }
        props.onVisibleChange(visible);
    };

    this.saveTrigger = function (node) {
        _this3.trigger = node;
    };
}, _temp);


Object.assign(Popover, {
    Animation: Animation,
    Trigger: Trigger,
    Placement: Placement
});

(0, _reactLifecyclesCompat.polyfill)(Popover);
exports.default = Popover;
exports.prefixCls = _style.prefixCls;